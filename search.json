[{"title":"Linux安装Redis","path":"/2023/09/02/Linux安装Redis/","content":"A、CentOS安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061下载地址：http://redis.io/download安装步骤：# 安装gccyum install gcc -yyum install wget -yyum install make#把下载好的redis‐*.tar.gz放在/usr/local文件夹下，并解压cd /usr/localwget http://download.redis.io/releases/redis-6.2.6.tar.gztar xzf redis-6.2.6.tar.gz# 进入到解压好的redis‐*目录下，进行编译与安装cd redis-6.2.6make#修改配置#后台启动daemonize yes#关闭保护模式，开启的话，只有本机才可以访问redisprotected‐mode no#需要注释掉bind#bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）#启动服务redis‐server redis.conf#Redis服务查看、开启、关闭#通过ps -ef|grep redis命令查看Redis进程；ps -ef|grep redis#开启Redis服务操作通过/etc/init.d/redis_6379 start命令，也可通过（service redis_6379 start）；service redis_6379 start#关闭Redis服务操作通过/etc/init.d/redis_6379 stop命令，也可通过（service redis_6379 stop）；service redis_6379 stop#启动服务src/redis‐server redis.conf#进入redis客户端src/redis‐cli#退出客户端quit#退出redis服务：pkill redis‐servekill 进程号src/redis‐cli shutdown#注意:过程中提示tcl 需要更新 ，执行一下命令yum install tcl 修改配置 12345678910#修改配置#后台启动daemonize yes#关闭保护模式，开启的话，只有本机才可以访问redisprotected‐mode no#需要注释掉bind#bind 127.0.0.1 （bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可） B、Ubuntu安装12345678910111213141516#在 Ubuntu 系统安装 Redis 可以使用以下命令:sudo apt-get updatesudo apt-get install redis-server#启动 Redisredis-server#查看 redis 是否启动？redis-cli#以上命令将打开以下终端：redis 127.0.0.1:6379&gt;127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。redis 127.0.0.1:6379&gt; pingPONG以上说明我们已经成功安装了redis。","tags":["Linux","Redis"],"categories":["Linux"]},{"title":"Linux安装MySQL","path":"/2023/09/01/Linux安装MySQL/","content":"A、MySQL基础安装12345678910111213141516171819#CentOS安装 下载rpm文件wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpmyum localinstall mysql57-community-release-el7-8.noarch.rpm -yyum install mysql-community-server -y# 启动MySQL服务systemctl start mysqld# 查看运行状态systemctl status mysqld# 设置开机启动systemctl enable mysqld#重启systemctl restart mysqld#修改root本地登录密码, 通过一下命令找到数据库初始密码**grep &#x27;temporary password&#x27; /var/log/mysqld.log#通过 &#x27;mysql -uroot -p&#x27; 进入到数据库中，修改数据库密码**或者Navcat客户端mysql -uroot -p B、设置密码123456789101112#如果要使用简单密码，请先执行一面设置。mysql简单密码5.7版本（可选）mysql&gt; set global validate_password_policy=0; set global validate_password_mixed_case_count=0; set global validate_password_number_count=3; set global validate_password_special_char_count=0; set global validate_password_length=3; #设置数据库密码Mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mysql_Ro0t#0615!^@#&#x27;;#刷新权限Mysql&gt; flush privileges; C、设置账户允许远程访问12345678#允许远程访问Mysql&gt;grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;mysql_Ro0t#0615!^@#&#x27; with grant option;Mysql&gt;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;mysql_Ro0t#0615!^@#&#x27; with grant option;#刷新权限Mysql&gt;flush privileges; D、创建新用户123456#新建用户#格式:create user &quot;username&quot;@&quot;host&quot; identified by &quot;password&quot;;create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123&#x27;;#授权#格式：grant privileges on databasename.* to &#x27;username&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;PASSWORD&#x27;; F、扩展：（未验证） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#修改mysql存放位置cp -rf /var/lib/mysql/* /mnt/data/mysqldata/data/chown -R mysql.mysql /mnt/data/mysqldatavim /etc/my.cnfjoin_buffer_size = 128Msort_buffer_size = 2Mread_rnd_buffer_size = 2M#datadir=/var/lib/mysqldatadir=/mnt/data/mysqldata/datasocket=/mnt/data/mysqldata/data/mysql.socksocket=/var/lib/mysql/mysql.socklower_case_table_names=1#Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0max_connections=1000max_connect_errors=300\\#Recommended in standard MySQL setupsql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION[mysqld_safe]\\#log-error=/var/log/mysqld.loglog-error=/mnt/data/mysqldata/log/mysqld.logpid-file=/mnt/data/mysqldata/run/mysqld/mysqld.pid\\#pid-file=/var/run/mysqld/mysqld.pid[mysql] ## 这里加2行，避免mysql -uroot -p的时候报找不到sock文件socket=/mnt/data/mysqldata/data/mysql.sockwq： 这里保存——————————————————————————————————#以下暂时不用———————————————————————————————— vim /etc/init.d/mysqld ## 修改下面的变量get_mysql_option mysqld datadir &quot;/home/mysql3306/data&quot;#get_mysql_option mysqld datadir &quot;/var/lib/mysql&quot;datadir=&quot;$result&quot;get_mysql_option mysqld socket &quot;$datadir/mysql.sock&quot;socketfile=&quot;$result&quot;get_mysql_option mysqld_safe log-error &quot;/home/mysql3306/log/mysqld.log&quot;#get_mysql_option mysqld_safe log-error &quot;/var/log/mysqld.log&quot;errlogfile=&quot;$result&quot;get_mysql_option mysqld_safe pid-file &quot;/home/mysql3306/run/mysqld/mysqld.pid&quot;#get_mysql_option mysqld_safe pid-file &quot;/var/run/mysqld/mysqld.pid&quot;——————————————————————————————————#重启systemctl restart mysqld#验证下是否数据都在mysql -uroot -p&#x27;lbMysql_!@#&#x27; Mysql&gt; use mysql;desc db；mysql&gt;show global variables like &quot;%datadir%&quot;;","tags":["Linux","MySQL"],"categories":["Linux"]},{"title":"Linux安装JDK","path":"/2023/08/31/Linux安装JDK/","content":"1、CentOS安装JDK jdk1.8下载地址：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html jdk11下载地址：https://www.oracle.com/java/technologies/javase-jdk11-downloads.html jdk14下载地址：https://www.oracle.com/java/technologies/javase-jdk14-downloads.html A、方式一（rpm方式）12345678910#需要提前下载好rpm包#安装之前检测jdk是否安装rpm -qa | grep java#执行安装rpm -ivh jdk-8u251-linux-x64.rpm #检测jdk版本java -version B、方式二（压缩包）1234567891011121314151617181920212223242526272829303132333435363738394041#需要提前下载好jdk-8u251-linux-x64.tar.gztar -zvxf jdk-8u251-linux-x64.tar.gz#配置环境变量sudo vi /etc/profile#将一下配置添加到文件末尾（注意JAVA_HOME的位置）#javaexport JAVA_HOME=/usr/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libsudo tee /etc/profile &lt;&lt;-&#x27;EOF&#x27;export JAVA_HOME=/home/yongzheng/application/jdk/jdk1.8.0_301export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libexport M2_HOME=/home/yongzheng/application/mavenexport PATH=$PATH:$M2_HOME/binEOF#重新加载配置source /etc/profile#验证码java -version#MACsudo tee ~/.bash_profile &lt;&lt;-&#x27;EOF&#x27;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_333.jdk/Contents/Homeexport M2_HOME=/Library/Java/Maven/apache-maven-3.8.6export GRADLE_HOME=/Library/Java/Gradle/gradle-7.4.2export GRADLE_USER_HOME=/Library/Java/Repositoryexport PATH=$JAVA_HOME/bin:$M2_HOME/bin:$GRADLE_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libEOF C、方式三（yum）123456789101112131415161718192021222324252627282930313233343536373839404142#搜索jdk安装包yum search java|grep jdk#搜索jdk 1.8.0版本yum search java|grep jdk | grep 1.8.0Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fastjava-1.8.0-openjdk.i686 : OpenJDK Runtime Environment 8java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment 8java-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility-debug.i686 : OpenJDK 8 accessibility connectorjava-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK 8 accessibilityjava-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment 8 with full debug onjava-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment 8 with full debugjava-1.8.0-openjdk-demo.i686 : OpenJDK Demos 8java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos 8java-1.8.0-openjdk-demo-debug.i686 : OpenJDK Demos 8 with full debug onjava-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos 8 with full debug onjava-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment 8 withjava-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment 8 withjava-1.8.0-openjdk-headless.i686 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless.x86_64 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with fulljava-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with fulljava-1.8.0-openjdk-javadoc.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK 8 API documentation forjava-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK 8 API documentation compressedjava-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src-debug.i686 : OpenJDK Source Bundle 8 for packages withjava-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle 8 for packages with#安装下载jdk1.8，下载之后默认的目录为： /usr/lib/jvm/yum install java-1.8.0-openjdk#验证码java -version 2、Ubuntu安装JDKA、方式一12345678#搜索可用jdk列表sudo apt search openjdk-8#安装jdksudo apt-get install openjdk-8-jdk#验证码java -version B、方式二（压缩包）123456789101112131415161718#需要提前下载好jdk-8u251-linux-x64.tar.gztar -zvxf jdk-8u251-linux-x64.tar.gz#配置环境变量sudo vi /etc/profile#将一下配置添加到文件末尾（注意JAVA_HOME的位置）#javaexport JAVA_HOME=/usr/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib#重新加载配置source /etc/profile#验证码java -version","tags":["Linux","JDK"],"categories":["Linux"]},{"title":"Linux工具安装","path":"/2023/08/31/Linux工具安装/","content":"1、lrzsz工具（上传下载）123456789#Ubuntu下载安装包sudo apt-get install -y lrzsz#CentOS下载安装包yum install -y lrzsz#上传文件rz#下载文件sz 文件名 2、sftp工具（上传下载）1234567891011121314151617181920212223#Xshell的sftp工具#查看服务器的位置pwd#查看本机的位置lpwd#固定本机的位置lcd#上传文件 或直接put 使用文件弹出框上传#将本机lcd默认路径下的abc.txt 上传到服务器现在的位置put abc.txt#上传多个文件mput *.txt#下载文件#将服务器现在位置的abc.txt文件，下载到lcd默认的本机的位置get abc.txt #下载多个mget *.txt 3、openssh-server工具（ssh远程）1234567# Xshell无法SSH连接Ubuntu #下载ssh服务sudo apt-get install openssh-server# 查看Ubuntu是否开启22端口netstat -ntlp | grep 22#检测端口是否开启telnet 192.168.3.244 22 4、sshpass工具（ssh远程）1234567891011121314151617181920212223242526272829303132333435363738394041# 安装软件包sudo apt-get install sshpass# 直接远程Linux主机# sshpass -p password ssh -p port username@IP 默认22端口sshpass -p xxx ssh root@192.168.11.11#从密码文件读取文件内容作为密码去远程连接主机sshpass -f xxx.txt ssh root@192.168.11.11#从远程主机上拉取文件到本地sshpass -p &#123;密码&#125; scp &#123;用户名&#125;@&#123;主机IP&#125;:$&#123;远程主机目录&#125; $&#123;本地主机目录&#125;#将主机目录文件拷贝至远程主机目录sshpass -p &#123;密码&#125; scp $&#123;本地主机目录&#125; &#123;用户名&#125;@&#123;主机IP&#125;:$&#123;远程主机目录&#125; #远程执行命令sshpass -p password ssh username@host &lt;cmd&gt;sshpass：用于非交互的ssh 密码验证使用 -p 参数指定明文密码，然后直接登录远程服务器。 它支持密码从命令行,文件,环境变量中读取1、从命令行方式传递密码sshpass -p user_password ssh user_name@192.168.1.2 【登录远程机器】sshpass -p user_password scp -P22 root@192.168.1.2:/home/test ./ 【远程机器/home/test 复制到本机当前目录】还可以加参数 -q 【去掉进度显示】2、从文件读取密码echo &quot;user_password&quot; &gt; user.passwdsshpass -f user.passwd ssh user_name@192.168.1.23、从环境变量获取密码export SSHPASS=&quot;user_password&quot;sshpass -e ssh user_name@192.168.1.2 4、sshpass -p user_password ssh -o StrictHostKeyChecking=no user_name@192.168.1.2 【-o StrictHostKeyChecking=no 表示远程连接时不提示是否输入yes/no】5、使用sshpass远程免密，在远程主机上执行shell命令，如下远程执行命令：touch /opt/file.txtsshpass -p user_password ssh -o StrictHostKeyChecking=no user_name@192.168.1.2 touch /opt/file.txt[注：shell命令要和sshpass命令写在一行] 5、ufw防火墙12345678910111213141516171819202122232425#安装防火墙sudo apt-get install ufw#防火墙开启sudo ufw enable#防火墙重启sudo ufw reload#关闭防火墙sudo ufw disable#开放22端口sudo ufw allow 22#禁用22端口sudo ufw delete allow 22#查看端口开启状态sudo ufw status#允许此IP访问所有的本机端口sudo ufw allow from 192.168.3.135#禁止外部访问SMTP服务sudo ufw deny smtp#删除上面建立的某条规则sudo ufw delete allow smtp #推荐使用sudo apt-get install ufwsudo ufw enablesudo ufw default deny 6.定时任务 12345678910111213141516171819202122232425#安装定时工具yum install cronie#启动服务service crond start #重启服务service crond restart #关闭服务service crond stop #重新加载服务service crond reload #查看状态service crond status 0 0 6 * * ? true &gt; /var/log/nginx/access.log0 0 6 * * ? true &gt; /var/log/nginx/error.log:wq #保存# 编辑定时命令 出发vim编辑器crontab -e#查看当前所有定时任务crontab -l#删除当前所有定时任务crontab -r","tags":["Linux"],"categories":["Linux"]},{"title":"关于","path":"/about/index.html","content":"关于我我是一个在命运长河里挣扎的小鱼，90后，目前是小白一枚。虽然心中不甘，但是目前确实是 Worst One 。目标是成为全栈工程师、系统架构师。虽然前路迷茫，但是我会一步一步往前走。 关于主题Hexo - LiveForCode 主题是根据 BNDong的博客样式复制过来的，其中也借鉴了 Hexo - NexT主题的样式。可能这个主题还有很多不尽人意的地方，在后续的阶段我会不断地完善，如果有关于主题的相关问题，欢迎联系我。"},{"title":"Linux安装JDK","path":"/notes/Linux安装JDK.html","content":"1、CentOS安装JDK jdk1.8下载地址：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html jdk11下载地址：https://www.oracle.com/java/technologies/javase-jdk11-downloads.html jdk14下载地址：https://www.oracle.com/java/technologies/javase-jdk14-downloads.html A、方式一（rpm方式）12345678910#需要提前下载好rpm包#安装之前检测jdk是否安装rpm -qa | grep java#执行安装rpm -ivh jdk-8u251-linux-x64.rpm #检测jdk版本java -version B、方式二（压缩包）1234567891011121314151617181920212223242526272829303132333435363738394041#需要提前下载好jdk-8u251-linux-x64.tar.gztar -zvxf jdk-8u251-linux-x64.tar.gz#配置环境变量sudo vi /etc/profile#将一下配置添加到文件末尾（注意JAVA_HOME的位置）#javaexport JAVA_HOME=/usr/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libsudo tee /etc/profile &lt;&lt;-&#x27;EOF&#x27;export JAVA_HOME=/home/yongzheng/application/jdk/jdk1.8.0_301export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libexport M2_HOME=/home/yongzheng/application/mavenexport PATH=$PATH:$M2_HOME/binEOF#重新加载配置source /etc/profile#验证码java -version#MACsudo tee ~/.bash_profile &lt;&lt;-&#x27;EOF&#x27;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_333.jdk/Contents/Homeexport M2_HOME=/Library/Java/Maven/apache-maven-3.8.6export GRADLE_HOME=/Library/Java/Gradle/gradle-7.4.2export GRADLE_USER_HOME=/Library/Java/Repositoryexport PATH=$JAVA_HOME/bin:$M2_HOME/bin:$GRADLE_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libEOF C、方式三（yum）123456789101112131415161718192021222324252627282930313233343536373839404142#搜索jdk安装包yum search java|grep jdk#搜索jdk 1.8.0版本yum search java|grep jdk | grep 1.8.0Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fastjava-1.8.0-openjdk.i686 : OpenJDK Runtime Environment 8java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment 8java-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility-debug.i686 : OpenJDK 8 accessibility connectorjava-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK 8 accessibilityjava-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment 8 with full debug onjava-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment 8 with full debugjava-1.8.0-openjdk-demo.i686 : OpenJDK Demos 8java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos 8java-1.8.0-openjdk-demo-debug.i686 : OpenJDK Demos 8 with full debug onjava-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos 8 with full debug onjava-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment 8 withjava-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment 8 withjava-1.8.0-openjdk-headless.i686 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless.x86_64 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with fulljava-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with fulljava-1.8.0-openjdk-javadoc.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK 8 API documentation forjava-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK 8 API documentation compressedjava-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src-debug.i686 : OpenJDK Source Bundle 8 for packages withjava-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle 8 for packages with#安装下载jdk1.8，下载之后默认的目录为： /usr/lib/jvm/yum install java-1.8.0-openjdk#验证码java -version 2、Ubuntu安装JDK A、方式一123456789#搜索可用jdk列表sudo apt search openjdk-8#安装jdksudo apt-get install openjdk-8-jdk#验证码java -version B、方式二（压缩包）123456789101112131415161718#需要提前下载好jdk-8u251-linux-x64.tar.gztar -zvxf jdk-8u251-linux-x64.tar.gz#配置环境变量sudo vi /etc/profile#将一下配置添加到文件末尾（注意JAVA_HOME的位置）#javaexport JAVA_HOME=/usr/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib#重新加载配置source /etc/profile#验证码java -version"},{"title":"Linux工具安装","path":"/notes/Linux工具安装.html","content":"1、lrzsz工具（上传下载）123456789#Ubuntu下载安装包sudo apt-get install -y lrzsz#CentOS下载安装包yum install -y lrzsz#上传文件rz#下载文件sz 文件名 2、sftp工具（上传下载）1234567891011121314151617181920212223#Xshell的sftp工具#查看服务器的位置pwd#查看本机的位置lpwd#固定本机的位置lcd#上传文件 或直接put 使用文件弹出框上传#将本机lcd默认路径下的abc.txt 上传到服务器现在的位置put abc.txt#上传多个文件mput *.txt#下载文件#将服务器现在位置的abc.txt文件，下载到lcd默认的本机的位置get abc.txt #下载多个mget *.txt 3、openssh-server工具（ssh远程）1234567# Xshell无法SSH连接Ubuntu #下载ssh服务sudo apt-get install openssh-server# 查看Ubuntu是否开启22端口netstat -ntlp | grep 22#检测端口是否开启telnet 192.168.3.244 22 4、sshpass工具（ssh远程）123456789101112131415161718192021222324252627282930313233343536373839404142# 安装软件包sudo apt-get install sshpass# 直接远程Linux主机# sshpass -p password ssh -p port username@IP 默认22端口sshpass -p xxx ssh root@192.168.11.11#从密码文件读取文件内容作为密码去远程连接主机sshpass -f xxx.txt ssh root@192.168.11.11#从远程主机上拉取文件到本地sshpass -p &#123;密码&#125; scp &#123;用户名&#125;@&#123;主机IP&#125;:$&#123;远程主机目录&#125; $&#123;本地主机目录&#125;#将主机目录文件拷贝至远程主机目录sshpass -p &#123;密码&#125; scp $&#123;本地主机目录&#125; &#123;用户名&#125;@&#123;主机IP&#125;:$&#123;远程主机目录&#125; #远程执行命令sshpass -p password ssh username@host &lt;cmd&gt;sshpass：用于非交互的ssh 密码验证使用 -p 参数指定明文密码，然后直接登录远程服务器。 它支持密码从命令行,文件,环境变量中读取1、从命令行方式传递密码sshpass -p user_password ssh user_name@192.168.1.2 【登录远程机器】sshpass -p user_password scp -P22 root@192.168.1.2:/home/test ./ 【远程机器/home/test 复制到本机当前目录】还可以加参数 -q 【去掉进度显示】2、从文件读取密码echo &quot;user_password&quot; &gt; user.passwdsshpass -f user.passwd ssh user_name@192.168.1.23、从环境变量获取密码export SSHPASS=&quot;user_password&quot;sshpass -e ssh user_name@192.168.1.2 4、sshpass -p user_password ssh -o StrictHostKeyChecking=no user_name@192.168.1.2 【-o StrictHostKeyChecking=no 表示远程连接时不提示是否输入yes/no】5、使用sshpass远程免密，在远程主机上执行shell命令，如下远程执行命令：touch /opt/file.txtsshpass -p user_password ssh -o StrictHostKeyChecking=no user_name@192.168.1.2 touch /opt/file.txt[注：shell命令要和sshpass命令写在一行] 5、ufw防火墙12345678910111213141516171819202122232425#安装防火墙sudo apt-get install ufw#防火墙开启sudo ufw enable#防火墙重启sudo ufw reload#关闭防火墙sudo ufw disable#开放22端口sudo ufw allow 22#禁用22端口sudo ufw delete allow 22#查看端口开启状态sudo ufw status#允许此IP访问所有的本机端口sudo ufw allow from 192.168.3.135#禁止外部访问SMTP服务sudo ufw deny smtp#删除上面建立的某条规则sudo ufw delete allow smtp #推荐使用sudo apt-get install ufwsudo ufw enablesudo ufw default deny 6.定时任务 12345678910111213141516171819202122232425#安装定时工具yum install cronie#启动服务service crond start #重启服务service crond restart #关闭服务service crond stop #重新加载服务service crond reload #查看状态service crond status 0 0 6 * * ? true &gt; /var/log/nginx/access.log0 0 6 * * ? true &gt; /var/log/nginx/error.log:wq #保存# 编辑定时命令 出发vim编辑器crontab -e#查看当前所有定时任务crontab -l#删除当前所有定时任务crontab -r"},{"title":"Docker-Compose入门","path":"/wiki/docker/Docker-Compose入门.html","content":"1、Docker-Compose简介 Compose是一个用于定义和运行多容器Docker应用程序的工具。主要用来构建基于Docker的复杂应用,使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，您可以从配置中创建并启动所有服务。非常适合组合使用多个容器进行开发的场景。 2、Docker-Compose安装2.1、安装方式(二进制文件)12345678910#下载最新版的docker-compose文件 github地址：https://github.com/docker/compose/releasescurl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composecurl -L https://github.com/docker/compose/releases/download/2.5.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose#添加可执行权限 sudo chmod +x /usr/local/bin/docker-compose#测试安装结果 docker-compose --version docker-compose version 1.24.0, build 0aa59064 2.2、删除方式12#直接删除二进制文件sudo rm -rf /usr/local/bin/docker-compose 注：另一种方式请自行百度，这里不做过多介绍 3、常用命令3.1、Docker-Compose命令格式A、格式1docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...] B、选项（options）如下： 选项 描述 -f, –file FILE 指定Compose模板文件，默认为docker-compose.yml -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名 –verbose 输出更多调试信 –log-level LEVEL 设置日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL) -v, –version 打印版本并退出 -x-network-driver -x-network-driver C、命令（COMMAND）如下 命令 build 构建项目中的服务容器 bundle 从撰写文件生成Docker包 config 验证和查看compose文件配置 create 为服务创建容器。只是单纯的create，还需要使用start启动compose down 停止并删除容器，网络，镜像和数据卷 events 事件从容器接收实时事件 exec 在运行的容器中执行一个命令 help 获得一个命令的帮助 images 获得镜像列表 kill 通过发送SIGKILL信号来强制停止服务容器 logs 查看服务容器的输出 pause 暂停一个服务容器 port 打印某个容器端口所映射的公共端口 ps 列出项目中目前的所有容器 pull 拉取服务依赖的镜像 push 推送服务镜像 restart 重启项目中的服务 rm 删除所有（停止状态的）服务容器 run 在指定服务上执行一个命令 scale 设置指定服务运行的容器个数 start 启动已经存在的服务容器 stop 停止已经处于运行状态的容器，但不删除它 top 显示运行的进程 unpause 恢复处于暂停状态中的服务 up 自动完成包括构建镜像、创建服务、启动服务并关闭关联服务相关容器的一些列操作 version 打印版本信息 3.2、拉取镜像（pull） 拉取服务依赖的镜像。 A、命令：1234#格式：docker-compose pull [options] [SERVICE...]# 拉取服务依赖的镜像docker-compose pull B、选项包括： –ignore-pull-failures，忽略拉取镜像过程中的错误 –parallel，多个镜像同时拉取 –quiet，拉取镜像过程中不打印进度信息 3.3、构建容器（build） 构建（重新构建）项目中的服务容器 A、命令：12345#格式：docker-compose build [options] [--build-arg key=val...] [SERVICE...]#构建（重新构建）项目中的服务容器。docker-compose build B、选项包括： –compress 通过gzip压缩构建上下环境 –force-rm 删除构建过程中的临时容器 –no-cache 构建镜像过程中不使用缓存 –pull 始终尝试通过拉取操作来获取更新版本的镜像 -m, –memory MEM为构建的容器设置内存大小 –build-arg key&#x3D;val为服务设置build-time变量服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-composebuild来重新构建服务 3.4、创建容器（create） 为服务创建容器。 A、命令：12#格式：docker-compose create [options] [SERVICE...] B、选项包括： –force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容 –no-recreate参数–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数 –no-build：不创建镜像，即使缺失–build：创建容器前，生成镜像 3.2、运行服务（up）A、命令：12345678910#格式docker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]#启动所有服务docker-compose up#启动所有服务，后台运行docker-compose up -d#指定使用的Compose模板文件后台运行，默认为docker-compose.yml，可以多次指定。docker-compose -f docker-compose.yml up -d B、选项包括： -d： 在后台运行服务容器 –no-color： 不使用颜色来区分不同的服务的控制输出 –no-deps： 不启动服务所链接的容器 –force-recreate： 强制重新创建容器，不能与–no-recreate同时使用 –no-recreate： 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用 –no-build： 不自动构建缺失的服务镜像 –build： 在启动容器前构建服务镜像 –abort-on-container-exit： 停止所有容器，如果任何一个容器被停止，不能与-d同时使用 -t, –timeout TIMEOUT： 停止容器时候的超时（默认为10秒） –remove-orphans： 删除服务中没有在compose文件中定义的容器 –scale SERVICE&#x3D;NUM： 设置服务运行容器的个数，将覆盖在compose中通过scale指定的参数 3.3、列出容器列表（ps）A、命令：12345#格式：docker-compose ps [options] [SERVICE...]#列出所有容器列表docker-compose ps 3.4、启动容器（start） 启动已经存在的服务容器 A、命令：1234#格式：docker-compose start [SERVICE...]# 启动已经存在的服务容器。docker-compose start 3.5、重启服务（restart） 重启项目中的服务 A、命令：1234#格式：docker-compose restart [options] [SERVICE...]# 重启项目中的服务docker-compose restart B、选项包括： -t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒） 3.6、停止容器（stop）A、命令：12345#格式docker-compose stop [options] [SERVICE...]#停止正在运行的容器，可以通过docker-compose start 再次启动docker-compose stop B、选项包括： -t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒） 3.7、删除停止容器（rm） 删除所有（停止状态的）服务容器。 A、命令1234#格式：docker-compose rm [options] [SERVICE...]# 删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。docker-compose rm B、选项包括： –f, –force，强制直接删除，包括非停止状态的容器 -v，删除容器所挂载的数据卷 3.8、停止和删除容器（down） 停止并删除容器、网络、映像和卷 A、命令：12345#格式docker-compose down [options]#停止和删除容器、网络、卷、镜像。docker-compose down B、选项包括： –rmi type：删除镜像，类型必须是： all：删除compose文件中定义的所有镜像； local：删除镜像名为空的镜像 -v, –volumes：删除已经在compose文件中定义的和匿名的附在容器上的数据卷 –remove-orphans：删除服务中没有在compose中定义的容器docker-compose down停用移除所有容器以及网络相关 -t, –timeout: 指定关闭超时，以秒为单位。（默认值： 10） 3.9、查看日志（logs） 查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。 A、命令： 12345#格式docker-compose logs [options] [SERVICE...]#查看服务容器的输出docker-compose logs 3.10、docker-compose run 在指定服务上执行一个命令。 123docker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]# 在指定容器上执行一个ping命令。docker-compose run ubuntu ping www.baidu.com 3.11、docker-compose scale12#设置指定服务运行的容器个数。通过service=num的参数来设置数量docker-compose scale web=3 db=2 3.12、docker-compose pause12#暂停一个服务容器docker-compose pause [SERVICE...] 3.13、docker-compose kill12345docker-compose kill [options] [SERVICE...]#通过发送SIGKILL信号来强制停止服务容器。 #支持通过-s参数来指定发送的信号，例如通过如下指令发送SIGINT信号：docker-compose kill -s SIGINT 3.14、dokcer-compose config 验证并查看compose文件配置 1docker-compose config [options] 选项包括： –resolve-image-digests 将镜像标签标记为摘要 -q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息 –services 打印服务名，一行一个–volumes 打印数据卷名，一行一个 3.15、docker-compose exec1docker-compose exec [options] SERVICE COMMAND [ARGS...] 选项包括： -d 分离模式，后台运行命令。 –privileged 获取特权。 –user USER 指定运行的用户。 -T 禁用分配TTY，默认docker-compose exec分配TTY。 –index&#x3D;index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index&#x3D;1 web&#x2F;bin&#x2F;bash ，web服务中包含多个容器 3.16、docker-compose port12#显示某个容器端口所映射的公共端口。docker-compose port [options] SERVICE PRIVATE_PORT 选项包括： –protocol&#x3D;proto，指定端口协议，TCP（默认值）或者UDP–index&#x3D;index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1） 3.17、docker-compose push 推送服务依的镜像。 1docker-compose push [options] [SERVICE...] 选项包括： –ignore-push-failures 忽略推送镜像过程中的错误 3.18、docker-compose unpause12#恢复处于暂停状态中的服务。docker-compose unpause [SERVICE...] 3.19、查看帮助1234#查看帮助docker-compose helpdocker-compose -h 3.20、查看版本号1234#打印版本信息。docker-compose versiondocker-compose -v 3.21、查看正在运行的进程显示正在运行的进程 1docker-compose top 三、Docker-Compose模板文件1、Docker-Compose模板文件简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262Compose和Docker兼容性： Compose 文件格式有3个版本,分别为1, 2.x 和 3.x 目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本 常用参数： version # 指定 compose 文件的版本 services # 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称 build # 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值 context # context: 指定 Dockerfile 文件所在的路径 dockerfile # dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile) args # args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用) cache_from # v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用) labels # v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用) shm_size # v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用) command # 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式 configs # 不知道怎么用 cgroup_parent # 不知道怎么用 container_name # 指定容器的名称 (等同于 docker run --name 的作用) credential_spec # 不知道怎么用 deploy # v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm endpoint_mode # v3.3 版本中新增的功能, 指定服务暴露的方式 vip # Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址 dnsrr # DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址 labels # 指定服务的标签，这些标签仅在服务上设置 mode # 指定 deploy 的模式 global # 每个集群节点都只有一个容器 replicated # 用户可以指定集群中容器的数量(默认) placement # 不知道怎么用 replicas # deploy 的 mode 为 replicated 时, 指定容器副本的数量 resources # 资源限制 limits # 设置容器的资源限制cpus: &quot;0.5&quot; # 设置该容器最多只能使用 50% 的 CPU memory: 50M # 设置该容器最多只能使用 50M 的内存空间 reservations # 设置为容器预留的系统资源(随时可用)cpus: &quot;0.2&quot; # 为该容器保留 20% 的 CPUmemory: 20M # 为该容器保留 20M 的内存空间 restart_policy # 定义容器重启策略, 用于代替 restart 参数 condition # 定义容器重启策略(接受三个参数) none # 不尝试重启 on-failure # 只有当容器内部应用程序出现问题才会重启 any # 无论如何都会尝试重启(默认) delay # 尝试重启的间隔时间(默认为 0s) max_attempts # 尝试重启次数(默认一直尝试重启) window # 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s) update_config # 用于配置滚动更新配置 parallelism # 一次性更新的容器数量 delay # 更新一组容器之间的间隔时间 failure_action # 定义更新失败的策略 continue # 继续更新 rollback # 回滚更新 pause # 暂停更新(默认) monitor # 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0) max_failure_ratio # 回滚期间容忍的失败率(默认值为0) order # v3.4 版本中新增的参数, 回滚期间的操作顺序 stop-first #旧任务在启动新任务之前停止(默认) start-first #首先启动新任务, 并且正在运行的任务暂时重叠 rollback_config # v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略 parallelism # 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚 delay # 每个组回滚之间的时间间隔(默认为0) failure_action # 定义回滚失败的策略 continue # 继续回滚 pause # 暂停回滚 monitor # 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0) max_failure_ratio # 回滚期间容忍的失败率(默认值0) order # 回滚期间的操作顺序 stop-first # 旧任务在启动新任务之前停止(默认) start-first # 首先启动新任务, 并且正在运行的任务暂时重叠 注意： 支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项 security_opt container_name devices tmpfs stop_signal links cgroup_parent network_mode external_links restart build userns_mode sysctls devices # 指定设备映射列表 (等同于 docker run --device 的作用) depends_on # 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项) 示例： docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动 默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系version: &#x27;3&#x27;services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres dns # 设置 DNS 地址(等同于 docker run --dns 的作用) dns_search # 设置 DNS 搜索域(等同于 docker run --dns-search 的作用) tmpfs # v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项) entrypoint # 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用) env_file # 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值 文件格式： RACK_ENV=development environment # 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用) expose # 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令 external_links # 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项) extra_hosts # 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用) healthcheck # v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令 test # 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串 NONE # 禁用容器的健康状态检测 CMD # test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] CMD-SHELL # test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;] 或者　test: curl -f https://localhost || exit 1interval: 1m30s # 每次检查之间的间隔时间timeout: 10s # 运行命令的超时时间retries: 3 # 重试次数start_period: 40s # v3.4 以上新增的选项, 定义容器启动时间间隔disable: true # true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同 image # 指定 docker 镜像, 可以是远程仓库镜像、本地镜像 init # v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程 isolation # 隔离容器技术, 在 Linux 中仅支持 default 值 labels # 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似 links # 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项) logging # 设置容器日志服务 driver # 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用) options # 指定日志的相关参数 (等同于 docker run --log-opt 的作用) max-size # 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作 max-file # 日志文件保留的数量 network_mode # 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项) networks # 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键 aliases # 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器 ipv4_address # IP V4 格式 ipv6_address # IP V6 格式示例: version: &#x27;3.7&#x27; services: test: image: nginx:1.14-alpine container_name: mynginx command: ifconfig networks: app_net: # 调用下面 networks 定义的 app_net 网络 ipv4_address: 172.16.238.10 networks: app_net: driver: bridge ipam: driver: default config: - subnet: 172.16.238.0/24pid: &#x27;host&#x27; # 共享宿主机的 进程空间(PID) ports # 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式SHORT 语法格式示例: - &quot;3000&quot; # 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口 - &quot;3000-3005&quot; # 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口 - &quot;8000:8000&quot; # 容器的 8000 端口和宿主机的 8000 端口建立映射关系 - &quot;9090-9091:8080-8081&quot; - &quot;127.0.0.1:8001:8001&quot; # 指定映射宿主机的指定地址的 - &quot;127.0.0.1:5000-5010:5000-5010&quot; - &quot;6060:6060/udp&quot; # 指定协议 LONG 语法格式示例:(v3.2 新增的语法格式)ports: - target: 80 # 容器端口 published: 8080 # 宿主机端口 protocol: tcp # 协议类型 mode: host # host 在每个节点上发布主机端口, ingress 对于群模式端口进行负载均衡 secrets # 不知道怎么用 security_opt # 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项) stop_grace_period # 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s) stop_signal # 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项) sysctls # 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项) ulimits # 设置容器的 limit userns_mode # 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项) volumes # 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用SHORT 语法格式示例: volumes: - /var/lib/mysql # 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中 - /opt/data:/var/lib/mysql # 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data - ./cache:/tmp/cache # 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置 - ~/configs:/etc/configs/:ro # 映射容器宿主机的目录到容器中去, 权限只读 - datavolume:/var/lib/mysql # datavolume 为 volumes 顶级键定义的目录, 在此处直接调用 LONG 语法格式示例:(v3.2 新增的语法格式)version: &quot;3.2&quot;services: web: image: nginx:alpine ports: - &quot;80:80&quot; volumes: - type: volume # mount 的类型, 必须是 bind、volume 或 tmpfs source: mydata # 宿主机目录 target: /data # 容器目录 volume: # 配置额外的选项, 其 key 必须和 type 的值相同 nocopy: true # volume 额外的选项, 在创建卷时禁用从容器复制数据 - type: bind # volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径 source: ./static target: /opt/app/static read_only: true # 设置文件系统为只读文件系统volumes: mydata: # 定义在 volume, 可在所有服务中调用 restart # 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart) no # 禁止自动重启容器(默认) always # 无论如何容器都会重启 on-failure # 当出现 on-failure 报错时, 容器重新启动 其他选项： domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir 上面这些选项都只接受单个值和 docker run 的对应参数类似 对于值为时间的可接受的值： 2.5s 10s 1m30s 2h32m 5h34m56s时间单位: us, ms, s, m， h 对于值为大小的可接受的值： 2b 1024kb 2048k 300m 1gb单位: b, k, m, g 或者 kb, mb, gb networks # 定义 networks 信息 driver # 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上 bridge # Docker 默认使用 bridge 连接单个主机上的网络 overlay # overlay 驱动程序创建一个跨多个节点命名的网络 host # 共享主机网络名称空间(等同于 docker run --net=host) none # 等同于 docker run --net=none driver_opts # v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序 attachable # driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信 ipam # 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的 driver # IPAM 驱动程序, bridge 或者 default config # 配置项 subnet # CIDR格式的子网，表示该网络的网段 external # 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误 name # v3.5 以上版本, 为此网络设置名称 文件格式示例：version: &quot;3&quot;services: redis: image: redis:alpine ports: - &quot;6379&quot; networks: - frontend deploy: replicas: 2 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure db: image: postgres:9.4 volumes: - db-data:/var/lib/postgresql/data networks: - backend deploy: placement: constraints: [ node.role == manager ]"},{"title":"Dockerfile的使用","path":"/wiki/docker/Dockerfile的使用.html","content":"8.1、 什么是Dockerfile Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境； &gt; 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 8.2 常用命令 命令 作用 FROM imgs&#x2F;docker_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir&#x2F;file dest_dir&#x2F;file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir&#x2F;file dest_dir&#x2F;file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 8.3 使用脚本创建镜像步骤： 8.3.1、创建目录1mkdir –p /usr/local/dockerjdk8 8.3.2、下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的&#x2F;usr&#x2F;local&#x2F;dockerjdk8目录8.3.3、创建文件Dockerfile vi Dockerfile1234567891011121314#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH 8.3.4、执行命令构建镜像1docker build -t=&#x27;jdk1.8&#x27; . 注意后边的空格和点，不要省略 8.3.5、查看镜像是否建立完成1docker images"},{"title":"Docker日志清理","path":"/wiki/docker/Docker日志清理.html","content":"3.1查询Docker产生的日志selectDockerLogs.sh12345678910#!/bin/bashecho &quot;======== docker containers logs file size ========&quot; logs=$(find /var/lib/docker/containers/ -name *-json.log) for log in $logs do ls -lh $log done 3.2清除Docker产生的日志cleanDockerLogs.sh1234567891011121314#!/bin/sh echo &quot;======== start clean docker containers logs ========&quot; logs=$(find /var/lib/docker/containers/ -name *-json.log) for log in $logs do echo &quot;clean logs : $log&quot; cat /dev/null &gt; $log done echo &quot;======== end clean docker containers logs ========&quot;"},{"title":"Docker安装","path":"/wiki/docker/Docker安装.html","content":"Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 注：如果安装过则可以，/var/lib/docker/保留包括图像，容器，卷和网络在内的内容。 2.1、CentOS安装 Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 2.1.1、检测版本12345678910111213141516#检测Linux版本 命令：uname -runame -r3.10.0-693.2.2.el7.x86_64yum 包更新到最新sudo yum update#安装系统依赖#需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的sudo yum install -y yum-utils device-mapper-persistent-data lvm2#设置yum源为阿里云 --添加软件源信息sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#更新yum缓存sudo yum makecache fast 2.1.2、查看所有docker版本12#查看所有docker版本#yum list docker-ce --showduplicates | sort -r 2.1.3、安装docker123#安装Docker-cesudo yum -y install docker-ce 2.1.4、启动服务并设置开机启动12345#启动 Docker 后台服务sudo systemctl start docker#设置开机启动sudo systemctl enable docker 2.1.4、安装后查看docker版本1234567891011121314151617181920212223#安装检测 当提示安装的版本号就已经标示安装完成docker --versionDocker version 18.09.6, build 481bc77156#或docker versionClient: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77156 Built: Sat May 4 02:34:58 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:02:43 2019 OS/Arch: linux/amd64 Experimental: false 2.2、Ubuntu安装2.2.1、使用apt-get命令安装1sudo apt-get install docker.io -y 2.2.2、查看Docker版本1sudo docker -v 2.2.3、查看Docker的信息1sudo docker info 2.2.4、查看帮助文档1sudo docker --help 2.3、Windows安装 Windows中安装需要注意，Windows版本不同安装包会有所不同,如有需要请自行百度。 扩展：A.卸载Docker1.卸载Docker-CE12sudo yum remove docker-cesudo rm -rf /var/lib/docker 2.移除旧版本Docker12345678910sudo yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-selinux \\docker-engine-selinux \\docker-engine B.开放Docker的2375端口12345678910111213141516171819#编辑docker文件sudo vim /lib/systemd/system/docker.service#找到ExecStart=/usr/bin/dockerd#在ExecStart=/usr/bin/dockerd后追加 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sockExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock#加载Docker守护线程systemctl daemon-reload#重启Dockersystemctl restart docker#查看端口 netstat -tnlp |grep 2375 #进行2375端口（或浏览器访问http://ip:2375/info） curl 127.0.0.1:2375/info C.配置镜像加速器 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决.新版的 Docker 使用 &#x2F;etc&#x2F;docker&#x2F;daemon.json（Linux）%programdata%\\docker\\config\\daemon.json（Windows） 来配置 Daemon。 请在该配置文件中加入（没有该文件的话，请先建一个）： 1、阿里云镜像加速 针对Docker客户端版本大于 1.10.0 的用户您可以通过修改daemon配置文件&gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器 12345678910#创建目录sudo mkdir -p /etc/docker# 追加配置sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://ortbpk0j.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 2、腾讯云镜像加速3、163镜像加速1234567sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 4、ustc镜像加速 ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc dockermirror的优势之一就是不需要注册，是真正的公共服务。https://lug.ustc.edu.cn/wiki/mirrors/help/docker 1234567sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker"},{"title":"Docker服务命令","path":"/wiki/docker/Docker服务命令.html","content":"这里主要介绍Linux版的Docker服务启动与关闭，如需Windows的请询问度娘，个人认为Windows版Docker还是很少装。本人也体验过Windows版从安装到使用都没用Linux版的好用。注：systemctl命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合 4.1、Docker服务的启动1systemctl start docker 4.2、Docker服务的停止1systemctl stop docker 4.3、Docker服务的重启1systemctl restart docker 4.4、查看Docker服务状态1systemctl status docker 4.5、设置Docker开机启动1systemctl enable docker"},{"title":"Docker容器命令","path":"/wiki/docker/Docker容器命令.html","content":"6.1 查看容器A。查看正在运行的容器 123456[root@gitlab ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdb71526cf08c seataio/seata-server:1.0.0 &quot;java -Djava.securit…&quot; 4 days ago Up 4 days 0.0.0.0:8091-&gt;8091/tcp seata-server8cbfdf71a92b nacos/nacos-server &quot;bin/docker-startup.…&quot; 12 days ago Up 12 days 0.0.0.0:8848-&gt;8848/tcp nacos900c164303b4 zookeeper &quot;/docker-entrypoint.…&quot; 6 weeks ago Up 2 weeks 2888/tcp, 3888/tcp, 8080/tcp, 0.0.0.0:2182-&gt;2181/tcp zookeeper-yz15f401418436 gitlab/gitlab-ce:latest &quot;/assets/wrapper&quot; 7 weeks ago Up 2 weeks (healthy) 0.0.0.0:2222-&gt;22/tcp, 0.0.0.0:8800-&gt;80/tcp, 0.0.0.0:8443-&gt;443/tcp gitlab-ce 结果描述: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 容器id 元镜像 创建时间 运行状态 端口映射 容器名 B、查看所有容器 1docker ps –a C、查看最后一次运行的容器 1docker ps –l D、查看停止的容器 1docker ps -f status=exited 6.2 创建与启动容器 创建容器常用的参数说明：docker run 参数 描述 –name 容器命名 -t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端 -d 守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器） -v 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录)。可以设置多个 注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。如果出现目录没有权限问题，加上--privileged=true -p 端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 注意：-v ：如果你共享的是多级的目录，可能会出现权限不足的提示。这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数–privileged&#x3D;true 来解决挂载的目录没有权限的问题。 12docker run -di --privileged=true --name=mycentos3 \\-v /usr/local/myhtml:/usr/local/myhtml centos:7 A、交互式运行 docker run -it –name&#x3D;容器名称 镜像名称:标签 注：退出交互式运行（退出时容器停止） exit 1docker run -it ubuntu /bin/bash 注意：交互式运行退出，容器则停止。 B、守护式方式创建容器：docker run -id –name&#x3D;容器名称 镜像名称:标签 1docker run -id ubuntu /bin/bash 注：运行一个需要长时间运行的容器，也可以理解为后台运行C、登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 6.3 启动与停止容器A、启动容器：12docker start 容器名称（或者容器ID）docker start $CONTAINER_ID/$NAME B、重启容器1docker restart $CONTAINER_ID/$NAME B、停止容器：1234567#立即终止docker stop 容器名称（或者容器ID）docker stop $CONTAINER_ID/$NAME#延时终止（秒）docker stop -t 20 容器名称（或者容器ID）docker stop -t 20 $CONTAINER_ID/$NAME C、删除容器12docker rm 容器名称（或者容器ID）docker rm $CONTAINER_ID/$NAME 扩展： 1234sudo docker rm -f $CONTAINER_ID/$NAME -f： --force=false 强制终止并删除一个运行中的容器 -l： --link=false 删除容器的连接，但保留容器 -v： --volumes=false删除容器所挂载的数据卷 D、查看容器 查看容器运行的各种参数 1sudo docker inspect $CONTAINER_ID/$NAME 查询容器的IP 1sudo docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $CONTAINER_ID/$NAME E、容器的导入导出 导出容器 1docker export 4968e97f588d -ubuntu.tar 导入容器 1ubuntu.tar | sudo docker import - yongzheng/ubuntu:v1.0 F、进入容器 attach命令 1sudo docker attach $CONTAINER_ID/$NAME exec命令 1sudo docker exec -it $CONTAINER_ID/$NAME /bin/bash 6.4、文件拷贝6.4.1、将文件拷贝到容器 如果我们需要将文件拷贝到容器内可以使用cp命令 123docker cp 需要拷贝的文件或目录 容器名称:容器文件或目录docker cp nginx.conf $CONTAINER_ID/$NAME:/etc/nginx/nginx.conf 6.4.2、从容器拷贝到宿主机 也可以将文件从容器内拷贝出来 123docker cp 容器名称:容器文件或目录 需要拷贝的文件或目录docker cp $CONTAINER_ID/$NAME:/etc/nginx/nginx.conf nginx.conf"},{"title":"Docker私有仓库","path":"/wiki/docker/Docker私有仓库.html","content":"7.1 私有仓库搭建与配置7.1.1、拉取私有仓库镜像（此步省略）1docker pull registry 7.1.2、启动私有仓库容器1docker run -di --name=registry -p 5000:5000 registry 7.1.3、打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到&#123;&quot;repositories&quot;:[]&#125; 表示私有仓库搭建成功并且内容为空7.1.4、修改daemon.json1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]&#125; 此步用于让 docker信任私有仓库地址 7.1.5、重启docker 服务1systemctl restart docker 7.2 镜像上传至私有仓库7.2.1、标记此镜像为私有仓库的镜像1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 7.2.2、再次启动私服容器1docker start registry 7.2.3、上传标记的镜像1docker push 192.168.184.141:5000/jdk1.8"},{"title":"Docker简介","path":"/wiki/docker/Docker简介.html","content":"1.1 什么是虚拟化 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件对资源充分利用虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是DockerDocker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 [GitHub](https://github.com/docker/docker) 上进行维护。 &#123;% image https://cdn.nlark.com/yuque/0/2019/png/672800/1576460023486-a6696364-7f30-4e87-a3f4-f520fe6bb40c.png#align=left&display=inline&height=186&originHeight=186&originWidth=555&size=58821&status=done&style=none&width=555 %&#125; Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件4.1 Docker服务器与客户端Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 4.2 Docker镜像与容器镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件；执行一个命令；打开一个窗口。也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。所以Docker容器就是：一个镜像格式；一些列标准操作；一个执行环境。Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 4.3 Registry（注册中心）Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 [https://hub.docker.com/](https://hub.docker.com/)"},{"title":"Docker镜像命令","path":"/wiki/docker/Docker镜像命令.html","content":"什么是Docker镜像 Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。最底端是一个文件引导系统，即bootfs，这很像典型的Linux/Unix的引导文件系统。Docker用户几乎永远不会和引导系统有什么交互。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要的一些文件，而这些文件就可以称为Docker镜像。 5.1 查看镜像1234567#查看镜像docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnacos/nacos-server latest 00b7582cb6e6 5 days ago 724MBgrafana/grafana latest 322e0a666176 11 days ago 233MBgitlab/gitlab-ce latest e6b464b98aff 12 days ago 1.92GB 返回描述： REPOSITORY TAG IMAGE ID CREATED SIZE 镜像名称 镜像标签 镜像ID 镜像的创建日期（不是获取该镜像的日期 镜像大小 注意：这些镜像都是存储在Docker宿主机的&#x2F;var&#x2F;lib&#x2F;docker目录下 5.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 123456789#docker search 镜像名称[root@gitlab ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 9634 [OK] mariadb MariaDB is a community-developed fork of MyS… 3500 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 702 [OK]centos/mysql-57-centos7 MySQL 5.7 SQL database server 77 mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 69 NAME DESCRIPTION STARS OFFICIAL AUTOMATED 仓库名称 镜像描述 用户评价，反应一个镜像的受欢迎程度 是否官方 自动构建，表示该镜像由Docker Hub自动构建流程创建的 5.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1#docker pull 镜像名称 例如，我要下载centos7镜像 12345sudo docker pull centos:7#默认latestsudo docker pull mysql#指定版本sudo docker pull mysql:5.7 5.4 删除镜像按镜像ID删除镜像 1234#docker rmi 镜像ID# 删除指定镜像sudo docker rmi $IMAGES_IDsudo docker rmi $REPOSITORY:$TAG 删除所有镜像 12# 删除所有镜像sudo docker rmi `sudo docker images -q` 5.5、容器保存镜像1sudo docker commit -a &quot;Yongzheng&quot; -m &quot;Ubuntu:16&quot; 4968e97f588d ubuntu:16.6 5.6、镜像备份12# sudo docker save -o 宿主机目录/镜像名.tar $IMAGES_ID/$REPOSITORY:$TAGsudo docker save -o nginx.tar nginx 5.7、镜像恢复12# sudo docker load -i 宿主机目录/镜像名.tarsudo docker load -i nginx.tar 5.8、Dockerfile创建镜像 根据Dockerfile创建 编写好Dockerfile文件，在同级目录下执行shell语句。 注： Dockerfile的编写请参考官网 1234#server:v1.0 server为镜像名字 v1.0为TAG（标签） # . 代表DockerFile 与当前目录为同级目录sudo docker build -t server:v1.0 . sudo docker build -t registry.cn-hangzhou.aliyuncs.com/yongzheng/jenkins:lts"},{"title":"Linux工具安装","path":"/wiki/ruoyi-vue-plus/Linux工具安装.html","content":"1、lrzsz工具（上传下载）123456789#Ubuntu下载安装包sudo apt-get install -y lrzsz#CentOS下载安装包yum install -y lrzsz#上传文件rz#下载文件sz 文件名 2、sftp工具（上传下载）1234567891011121314151617181920212223#Xshell的sftp工具#查看服务器的位置pwd#查看本机的位置lpwd#固定本机的位置lcd#上传文件 或直接put 使用文件弹出框上传#将本机lcd默认路径下的abc.txt 上传到服务器现在的位置put abc.txt#上传多个文件mput *.txt#下载文件#将服务器现在位置的abc.txt文件，下载到lcd默认的本机的位置get abc.txt #下载多个mget *.txt 3、openssh-server工具（ssh远程）1234567# Xshell无法SSH连接Ubuntu #下载ssh服务sudo apt-get install openssh-server# 查看Ubuntu是否开启22端口netstat -ntlp | grep 22#检测端口是否开启telnet 192.168.3.244 22 4、sshpass工具（ssh远程）123456789101112131415161718192021222324252627282930313233343536373839404142# 安装软件包sudo apt-get install sshpass# 直接远程Linux主机# sshpass -p password ssh -p port username@IP 默认22端口sshpass -p xxx ssh root@192.168.11.11#从密码文件读取文件内容作为密码去远程连接主机sshpass -f xxx.txt ssh root@192.168.11.11#从远程主机上拉取文件到本地sshpass -p &#123;密码&#125; scp &#123;用户名&#125;@&#123;主机IP&#125;:$&#123;远程主机目录&#125; $&#123;本地主机目录&#125;#将主机目录文件拷贝至远程主机目录sshpass -p &#123;密码&#125; scp $&#123;本地主机目录&#125; &#123;用户名&#125;@&#123;主机IP&#125;:$&#123;远程主机目录&#125; #远程执行命令sshpass -p password ssh username@host &lt;cmd&gt;sshpass：用于非交互的ssh 密码验证使用 -p 参数指定明文密码，然后直接登录远程服务器。 它支持密码从命令行,文件,环境变量中读取1、从命令行方式传递密码sshpass -p user_password ssh user_name@192.168.1.2 【登录远程机器】sshpass -p user_password scp -P22 root@192.168.1.2:/home/test ./ 【远程机器/home/test 复制到本机当前目录】还可以加参数 -q 【去掉进度显示】2、从文件读取密码echo &quot;user_password&quot; &gt; user.passwdsshpass -f user.passwd ssh user_name@192.168.1.23、从环境变量获取密码export SSHPASS=&quot;user_password&quot;sshpass -e ssh user_name@192.168.1.2 4、sshpass -p user_password ssh -o StrictHostKeyChecking=no user_name@192.168.1.2 【-o StrictHostKeyChecking=no 表示远程连接时不提示是否输入yes/no】5、使用sshpass远程免密，在远程主机上执行shell命令，如下远程执行命令：touch /opt/file.txtsshpass -p user_password ssh -o StrictHostKeyChecking=no user_name@192.168.1.2 touch /opt/file.txt[注：shell命令要和sshpass命令写在一行] 5、ufw防火墙12345678910111213141516171819202122232425#安装防火墙sudo apt-get install ufw#防火墙开启sudo ufw enable#防火墙重启sudo ufw reload#关闭防火墙sudo ufw disable#开放22端口sudo ufw allow 22#禁用22端口sudo ufw delete allow 22#查看端口开启状态sudo ufw status#允许此IP访问所有的本机端口sudo ufw allow from 192.168.3.135#禁止外部访问SMTP服务sudo ufw deny smtp#删除上面建立的某条规则sudo ufw delete allow smtp #推荐使用sudo apt-get install ufwsudo ufw enablesudo ufw default deny 6.定时任务 12345678910111213141516171819202122232425#安装定时工具yum install cronie#启动服务service crond start #重启服务service crond restart #关闭服务service crond stop #重新加载服务service crond reload #查看状态service crond status 0 0 6 * * ? true &gt; /var/log/nginx/access.log0 0 6 * * ? true &gt; /var/log/nginx/error.log:wq #保存# 编辑定时命令 出发vim编辑器crontab -e#查看当前所有定时任务crontab -l#删除当前所有定时任务crontab -r"},{"title":"Linux安装JDK","path":"/wiki/ruoyi-vue-plus/Linux安装JDK.html","content":"1、CentOS安装JDK jdk1.8下载地址：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html jdk11下载地址：https://www.oracle.com/java/technologies/javase-jdk11-downloads.html jdk14下载地址：https://www.oracle.com/java/technologies/javase-jdk14-downloads.html A、方式一（rpm方式）12345678910#需要提前下载好rpm包#安装之前检测jdk是否安装rpm -qa | grep java#执行安装rpm -ivh jdk-8u251-linux-x64.rpm #检测jdk版本java -version B、方式二（压缩包）1234567891011121314151617181920212223242526272829303132333435363738394041#需要提前下载好jdk-8u251-linux-x64.tar.gztar -zvxf jdk-8u251-linux-x64.tar.gz#配置环境变量sudo vi /etc/profile#将一下配置添加到文件末尾（注意JAVA_HOME的位置）#javaexport JAVA_HOME=/usr/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libsudo tee /etc/profile &lt;&lt;-&#x27;EOF&#x27;export JAVA_HOME=/home/yongzheng/application/jdk/jdk1.8.0_301export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libexport M2_HOME=/home/yongzheng/application/mavenexport PATH=$PATH:$M2_HOME/binEOF#重新加载配置source /etc/profile#验证码java -version#MACsudo tee ~/.bash_profile &lt;&lt;-&#x27;EOF&#x27;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_333.jdk/Contents/Homeexport M2_HOME=/Library/Java/Maven/apache-maven-3.8.6export GRADLE_HOME=/Library/Java/Gradle/gradle-7.4.2export GRADLE_USER_HOME=/Library/Java/Repositoryexport PATH=$JAVA_HOME/bin:$M2_HOME/bin:$GRADLE_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libEOF C、方式三（yum）123456789101112131415161718192021222324252627282930313233343536373839404142#搜索jdk安装包yum search java|grep jdk#搜索jdk 1.8.0版本yum search java|grep jdk | grep 1.8.0Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fastjava-1.8.0-openjdk.i686 : OpenJDK Runtime Environment 8java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment 8java-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility-debug.i686 : OpenJDK 8 accessibility connectorjava-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK 8 accessibilityjava-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment 8 with full debug onjava-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment 8 with full debugjava-1.8.0-openjdk-demo.i686 : OpenJDK Demos 8java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos 8java-1.8.0-openjdk-demo-debug.i686 : OpenJDK Demos 8 with full debug onjava-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos 8 with full debug onjava-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment 8 withjava-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment 8 withjava-1.8.0-openjdk-headless.i686 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless.x86_64 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with fulljava-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with fulljava-1.8.0-openjdk-javadoc.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK 8 API documentation forjava-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK 8 API documentation compressedjava-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src-debug.i686 : OpenJDK Source Bundle 8 for packages withjava-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle 8 for packages with#安装下载jdk1.8，下载之后默认的目录为： /usr/lib/jvm/yum install java-1.8.0-openjdk#验证码java -version 2、Ubuntu安装JDK A、方式一123456789#搜索可用jdk列表sudo apt search openjdk-8#安装jdksudo apt-get install openjdk-8-jdk#验证码java -version B、方式二（压缩包）123456789101112131415161718#需要提前下载好jdk-8u251-linux-x64.tar.gztar -zvxf jdk-8u251-linux-x64.tar.gz#配置环境变量sudo vi /etc/profile#将一下配置添加到文件末尾（注意JAVA_HOME的位置）#javaexport JAVA_HOME=/usr/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib#重新加载配置source /etc/profile#验证码java -version"}]